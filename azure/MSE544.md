# Azure Functions: Serverless computing on the cloud

This tutorial follows a very minimalist path to a working example of serverless,
owing to time constraints. We suggest viewing this as introductory steps towards 
developing comprehensive cloud computing 'builder' skills. 


## Links


- [Slides kilroy update this](https://docs.google.com/presentation/d/1R2HHfHYgmarje2q_0x42hMecUc7R6SFjI-ih1L05foQ/edit#slide=id.p)
- [Padlet for communications](https://padlet.com/robfatland/serverless)
- [This tutorial](https://github.com/robfatland/serverless/blob/main/azure/MSE544.md)


#### Software Installation Guides


- Install [VSCode](https://code.visualstudio.com/)
- Install the [Azure Functions Core Tools Extension in VSCode](https://github.com/Azure/azure-functions-core-tools#installing) kilroy update
- Mac Users: Install [.Net Core](https://dotnet.microsoft.com/download) kilroy test is this necessary and does it work


#### Reference Documentation


- [Microsoft Azure Functions overview](https://learn.microsoft.com/en-us/azure/azure-functions/)
- [Microsoft Azure Functions general structure](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference)
- [Microsoft Azure Functions specifically with Python](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python)
- [Function Apps](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings) are the execution context for Azure Functions
- [YouTube video on Azure Function best practices (and more)](https://youtu.be/kvTostlJp7M) kilroy check


#### Further reading




- [Serverless function design pattern introduction](https://www.twilio.com/docs/glossary/what-is-serverless-architecture) kilroy check
- [Using Serverless Functions for deep learning](https://www.serverless.com/blog/using-tensorflow-serverless-framework-deep-learning-image-recognition) kilroy
- [Code golf Sudoku solver blog by Jake VanDerplas](https://jakevdp.github.io/blog/2013/04/15/code-golf-in-python-sudoku/) 
- [Rustem Feyzkhanov's GitHub Lambda (AWS Serverless) adaptations library](https://github.com/ryfeus/lambda-packs) 



## Table of Contents


[Table of Contents (TOC)](#table-of-contents)


* [Overview](#overview)
* [1: Establish access to an Azure Subscription](#1-establish-access-to-an-azure-subscription)
* [2: Portal work](#2-portal-work)
* [3: On templates and code](#3-on-templates-and-code)
* [4: Switching to Visual Studio Code (VSCode)](#4-switching-to-visual-studio-code-vscode)
* [5: Installing Python and Extensions](#5-installing-python-and-extensions)
* [6: Creating an Azure Function in VSCode](#6-creating-an-azure-function-in-vscode)
* [7: Code break](#7-code-break)
* [8: Test locally](#8-test-locally)
* [9: Deploy to Azure](#9-deploy-to-azure)
* [10: Programmatic test](#10-programmatic-test)
* [Appendices](#appendices)
    + [Logging results in the Azure console](#logging-results-in-the-azure-console)
    + [Serverless computing and Azure Serverless Functions](#serverless-computing-and-azure-serverless-functions)
    + [Stretch Problem 1: Timing an Azure Function](#stretch-problem-1)
    + [Stretch Problem 2: Expanding an Azure Function](#stretch-problem-2)
    + [Stretch Problem 3: Binding an Azure Function](#stretch-problem-3)
    + [Docker review](#docker-review)
    + [Stretch Problem 1 example results](#stretch-problem-1-example-results)



## Overview

[TOC](#table-of-contents)


This section looks at some terminology and at the road ahead. 
Let's begin by defining *serverless computing* in more detail.


* Serverless computing is an important element of computing on the cloud
    * The goal of this work: Build some simple compute functionality on the (Azure) cloud without bothering with a server
    * A server is a computer that listens for traffic and responds; it requires some care and feeding
    * If we succeed: We get to skip the care and feeding part. This is called 'serverless'
    * The serverless brand name is '**Azure Function**'. On AWS it is '**Lambda Function**'
    * Advantages: **Low hassle, Secure, Scalable, $Cheap**
    * A serverless function requires a **trigger** to start it in motion
        * Example triggers: An automated 'alarm clock', an HTTP web request
    * We want to notice how system feedback helps us debug
    * Serverless functions tend to do *simpler* tasks compared to what we do with *containers*


* Milestones
    * 1: Use the Azure Portal to create a Hello World Azure Function V1 via web browser
    * 2: Set up your personal computer to be a Development Environment
        * Build locally, test locally, push to cloud -> Azure Function on the cloud V2
    * 3: Test the Azure Function on the cloud and learn some debugging methods




### Azure


[TOC](#table-of-contents)


* Microsoft Azure is one of the primary public clouds.
    * We develop cloud content using a local application called **Visual Studio Code** or [VSCode](https://code.visualstudio.com/)
* Jargon: *Scalable* means that the cloud can handle large demand by making lots of copies of an Azure Function that will run in parallel.
* Jargon: *Azure Function App* is an execution context for one or more Azure Functions; another type of organizing box
* Jargon: *Stateless* means that the Azure Function runs with no memory of what has happened in the past


> An **Azure Function** is set up under a *one-off transaction* model; so it is considered *stateless*. 
> However: An Azure Function can connect to persistent storage (say a database or object storage) which
> does introduce the idea of a *state*. Azure also provides an explicitly *stateful* version of Functions
> called '**Durable Functions**'.


> Working on the cloud: Things like storage or containers or a virtual machine or an Azure Function are
> generically called **Resources**. One thing to be on the lookout for are various types of virtual boxes
> that can contain resources. This is an organizational mechanism. Examples include Resource Groups and
> Storage Accounts. In the case of Azure Functions the 'virtual box' is called an Azure Function App. This
> can hold one or more Azure Functions (which actually conduct the business of doing something). 


### VSCode


Looking ahead, the **VSCode** application contains many **views** (information panels).


- **`EXPLORER`** view shows files in a folder
- **`RUN AND DEBUG`** view 
- **`EXTENSIONS`** view 
- **`AZURE`** view shows a **`RESOURCES`** list and a **`WORKSPACE`** (sub-views)
- **`DOCKER`** view 


When the view we need is not visible: We change the view. The view selector is a vertical strip
of icons on the left edge of the VSCode application window. This is called the **Activity Bar**
and each icon is a toggle switch for its corresponding view.



> A possible point of confusion: We use the term 'serverless' to emphasize the mindset of working
> with Azure Functions: We put together the code and let Azure worry about the computer that it will
> run on. **However** in the course of developing the Function on our own laptop: We *do* need a
> server. What is that server? That server *is* your laptop, running a little server program, 
> pretending to be a server in the cloud. As you go through this tutorial: Be on the lookout for 
> when VSCode gives you a URL to
> try out in your browser. This will start with the word **`localhost`** and that is what connects
> your browser to the little server running on your laptop. 


### Additional themes and jargon


* Azure Function components: A storage account, the code base, some configuration files
* __init__.py is the *recipe* for the Azure Function
* Security: We use *Anonymous*: Users do not need to authenticate to use a service
* Python environments exist and are configured here via a file `requirements.txt`



kilroy the following are vague and unhelpful



* Windows Python 3.8+ 64-bit PATH, PYTHONPATH: Can be a challenge
* On HTTP triggers: GET and POST are distinct *types*. Example code has “body parse” component; see the Appendix
* Where can results go? HTTP response, a new file in a Storage Account; or a line appended to an existing file; or a new entry in a database table
* More security: Private environment variables; key vault; etc: How to get code to GitHub safely?
* Debugging: Where does `logging.info` go?


### Getting help


Suppose you try to do something in the VSCode application but you get a mysterious error message. We suggest you might
find a solution by searching on **`VSCode Azure Function <error message copy-paste>`**. 

#### Serverless: What is it good for?

- Wildflowers
- Multimedia processing: execute a transformation in response to a file upload
- Database changes or change data capture: ensure changes meet quality standards
- IoT sensor input messages
- Stream processing at scale: vast streams are fine
- Chat bots: scaling automatically for peak demand
- Batch jobs scheduled tasks: intense parallel computation, IO or network access
- HTTP REST APIs and web apps: traditional request and response workloads
- Mobile back ends: ability to build on the REST API backend workload above the BaaS APIs
- Business logic: orchestration of microservice workloads
- Continuous integration pipeline: remove the need for pre-provisioned hosts

## 1 Establish access to an Azure Subscription 

[TOC](#table-of-contents)


* Log in to [portal.azure.com](https://portal.azure.com) to verify your access
* You authenticate by means of your UW NetID
    * When we use a program to log in 'as us' we use a different method


## 2 Portal work


[TOC](#table-of-contents)


Examine the [Azure portal](https://portal.azure.com) upper left corner: 



<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_001_portal.png" alt="drawing" width="500"/>


Top row...


- **Create a resource** is the starting point for manually getting cloud resources, also called *services*. 
- **Resource group** (abbreviated 'RG') is a virtual container (think 'project box') for related resources we use to build something with
- **Subscription** is a User account; it can contain many RGs
- **Marketplace** is a catalog of cloud resources
- **Storage account** is another organizing box: Specifically for containing various types of data storage
- **Azure Active Directory** is a tool for managing access and authentication
- **Virtual Machines** are computers: A specific and commonly used type of resource


Type 'function' in the top search window to zero in on Azure Function App (the full name of the Azure Function
service). 

<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_002_CreateFunctionAppButton.png" alt="drawing" width="200"/>
<BR>


Select Function App from the resulting list of Services. 
      


Click on the **Create** button to go to a *create* wizard that eventually builds an Azure Function. 
This Azure Function is basic, just 'hello world' caliber; but it does exist and run until we choose to delete it.
The reason to delete it is to stop paying for it. Resources that we start and then forget about, that continue
to cost money without serving any purpose, are called cloud zombies. 


    
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_003_CreateFunctionAppWizard1.png" alt="drawing" width="500"/>
    

kilroy finesse the jump to Review and Create and include what follows as cleaned up notes
    

Next tab is **Hosting** tab (image below). 
Notice that a Storage Account is created by default and associated
with the Function App. A Storage Account is a logical container like 
a Resource Group but specific to data storage modes
on the cloud. 

 
<BR><BR>

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/12_1_Function_App_Wizard_Hosting.png" alt="drawing" width="700"/>

<BR><BR>
   

Next comes the **Networking** tab: Keep defaults; nothing to do here.
 

Next comes the **Monitoring** tab. This offers to enable a service called Application Insights.
This helps track resource usage and debug problems. 
For now leave this Disabled (select 'No'). We come back to Application Insights use later in this tutorial
when we shift to using Visual Studio Code. 

<BR><BR>
   


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/13_1_Function_App_Wizard_Monitoring.png" alt="drawing" width="700"/>


<BR><BR>
   
The **Tagging** tab allows us to annotate an Azure Function with key-value pairs. 
Sometimes our efforts on the cloud are interrupted -- say for four months -- and when we return we find a list 
of engaged resources that can appear mysterious. Tagging is way to anticipate this problem.
The idea is to invent tags that behave like Question/Answer pairs. 'Who owns this resource?, Fred does!'
becomes the tag 'Owner' + 'Fred'. Other useful tag keys could include 'Project Title', 'Expiration Date', 
'Ok to delete after expiration?', and 'Email contact'. Each tag *key* would have a corresponding *value*.
In six months someone might be cleaning up this cloud subscription. If they come across a Storage Account
on Azure and they find your tags: They might check with you before deleting your valuable data forever. 
So tags can be extremely valuable.
 

<BR><BR>
   

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/14_1_Function_App_Wizard_Tagging.png" alt="drawing" width="700"/>

<BR><BR>
   

The final **Review / Create** tab allows you to launch the creation process. Look over the summary and click on **Create** at bottom left.

<BR><BR>
   

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/15_1_Function_App_Wizard_Review_Create.png" alt="drawing" width="500"/>

<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/15_2_Function_App_Wizard_Create_Button.png" alt="drawing" width="100"/>

<BR><BR>
   

If all goes well we arrive at a confirmation message.

<BR><BR>
   

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/16_1_Function_App_Wizard_Deployment_Complete.png" alt="drawing" width="600"/>

<BR><BR>
   

Now let's take stock of the Azure Function: Click on **Go to resource**.

<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/16_2_Function_App_Overview.png" alt="drawing" width="600"/>
<BR><BR>
   

There are four things to note here


* The upper left corner features a link to return to your Home view
* The left sidebar title is the name of your Azure Function
    * This means that your current view of the Portal is focused on your Azure Function
* The scrollable left side-bar is a context menu for the many facets of the Azure Function
    * By default *Overview* is selected and this is what we see in the main-central panel
* Along the top of the top of the main-center Overview pane is a series of common tasks: **Browse**, **Refresh**, **Stop**, **Restart** etcetera
    * These refer to the state of the Azure Function
    * Note that the Function can be stopped without it being deleted


Over to the right in the main panel is the URL associated with the Azure Function

<BR>

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/16_3_Function_App_URL.png" alt="drawing" width="600"/>

<BR>

Copy this URL to a new browser tab. 
This should open a default page in your browser. 
This is what an Azure Function does when we do not give it a 
specific job to do (code to run). We verify here that the Function was 
created and works, albeit it is merely hello world. 


Return to the Azure Function and navigate up a level to **Home** and then down into 
the default **Resource Group**. Here we should find a listing of the resources in 
this Resource Group including the Serverless Function we just created. 

<BR><BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/16_4_Resource_Group_Overview.png" alt="drawing" width="600"/>

<BR><BR>
   

This concludes the creation of an Azure Function using the Azure portal.
The last thing to do is select your Azure Function and Delete it.

    
***Accomplished***
    
- Experience with the browser/portal path to cloud resource creation
- Navigated the Azure cloud
- Introduction to ephemeral cloud thinking: Lasting for a very short time (while we experiment/learn)


## 3 On templates and code

    
[TOC](#table-of-contents)

    
In the portal Overview view of this Azure Function App: Notice the **JSON view** link
at the upper right. Click this link to see a pop-up
text document that describes the Azure Function using a descriptive
protocol called JavaScript Object Notation (JSON). This JSON text can be used as a template
to create new Azure Function Apps, i.e. using code rather than manually.


    
## 4 Switching to Visual Studio Code (VSCode)


[TOC](#table-of-contents)


If necessary: Install the development application 
Visual Studio Code, abbreviated **VSCode**. 
VSCode enables
us to develop and test Azure Functions locally (on a laptop).
VSCode is integrated with Azure so it also makes it easy to deploy
an Azure Function to the cloud once it is working properly.  


- [VSCode installer link](https://code.visualstudio.com/)
    - Default installation on a PC is in `C:\Users\myusername\AppData\Local\Programs\Microsoft VS Code`
    - Default installation adds VSCode to PATH (requires shell restart) 
- Start and configure VSCode
 

***kilroy revisit and adjust this: what is already installed? which Python, if necessary?***
    
    
- Download and install Python 3.9.12 from [www.python.org](www.python.org).

 
<BR><BR>   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/PVSCTerm_01.png" alt="drawing" width="400"/>
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/PVSCTerm_02.png" alt="drawing" width="400"/>
<BR><BR>

 
- ***IMPORTANT: Run the installer with defaults settings, and DO NOT SELECT "Add Python to PATH"***

 
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/PVSCTerm_03.png" alt="drawing" width="400"/>
<BR><BR>
 
 
- Completely close and re-open VSCode
- Open the command palette with ctrl+shift+p
- Run the "Python: Select interpreter" command

 
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/PVSCTerm_04.png" alt="drawing" width="400"/>
<BR><BR>


- Choose Python 3.9.12
- Ensure it is the one installed to "~\AppData\Local\..."
    
    
***kilroy is the above still correct? how to 'ensure'???***
 
 
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/PVSCTerm_05.png" alt="drawing" width="400"/>
<BR><BR>
 
 
- If you have an Azure function already: Delete it
- Create a new Azure function from scratch per the tutorial instructions below 
- When it comes to selecting a Python interpreter for the virtual environment choose "py-3.9"

 
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/PVSCTerm_06.png" alt="drawing" width="400"/>
<BR><BR>
 
- Continue with the tutorial steps from here.


## 5 Installing Python and Extensions

    
[TOC](#table-of-contents)

    
* Verify you have Python 3.8+ 64-bit installed on your development system: `python --version`
* Update `pip` using the command `python -m pip install --upgrade pip`
* Install the Python **requests** package:  `python -m pip install requests`
    * This enables a Python program to talk to a website
    * More accurately: The Python program can send and receive HyperText Transfer Protocol (HTTP) messages 
* Start ***VSCode*** and sign in to Azure
    * On the Terminal type `az login`: This should launch NetID authentication
    * Verify: Click the Azure icon on the Activity Bar (stylized **A**) and check the status bar (bottom)
* Install *Azure Functions Core Tools* 
    * Use [this URL](https://github.com/Azure/azure-functions-core-tools#installing)
    * To see if it installed: From within VSCode
        * Activity Bar (vertical icon bar at the far left) select Extensions icon
        * Search for Azure Functions Core Tools
    * Mac Users: It may be helpful to [install **.Net Core**](https://dotnet.microsoft.com/download)


## 6 Creating an Azure Function in VSCode


[TOC](#table-of-contents)

    
### Connecting to Azure from VSCode


VSCode starts with a tabbed Welcome page. Dismiss it to show some Ctrl-key shortcuts. 


The VSCode console layout includes an **Activity Bar** at the extreme left (a vertical sequence of icons) and a **Sidebar**
adjacent to this. Your **Activity Bar** selection will determine the dropdowns and options that appear in the **Sidebar**.
At the bottom of the VSCode console is a status bar. This will include your sign-in status. If you see 
*`Azure:yourNetID@uw.edu`* (with the *Azure* icon selected in the Activity Bar) then you are signed in. 


If you are not signed in to Azure: 
Type ctrl + shift + p to bring up a little Command prompt window with a lot of listed options. 
Type `Azure Sign In` at the prompt; this acts like a search so now you can select this option 
and authenticate (log in) to Azure. Again: Verify by checking the status bar at the 
bottom of the VSCode console. Bear in mind that while you are authenticated into Azure, the VSCode
app is running on your laptop; so there is a 'here' and a 'there' involved in your work. 'Here' is
on your laptop and 'there' is on the Azure cloud. 

    
* Use ctrl + j to bring up a tabbed console in the lower part of the VSCode main window.  

    
* Toggle on the Azure icon in the activity bar. 
    
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_005_AzureActivityIcon.png" alt="drawing" width="80"/>
<BR>
    
    
    
The Azure toggle brings up a RESOURCES panel and a WORKSPACE panel. (If these are
not visible: Use the **`...`** dropdown menu at the upper right to select them.)

    
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_004_VSCodeAzureView.png" alt="drawing" width="500"/>
<BR>
    

We commence to build and test an Azure Function locally, on our own computer ('here'). 
    
* Hover your cursor over the **WORKSPACE** panel to bring up a context menu at the upper right
* Click on the +-lightning-bolt (Create Function) icon in this menu

    
> Uh oh I get an error where a fix is described here: https://stackoverflow.com/questions/71837658/error-eperm-operation-not-permitted-scandir-c-users-node-modules-re
    

kilroy not anymore this:

<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_004_VSCodeAzureView.png" alt="drawing" width="80"/>

<BR>
   

Create the host folder and make the following choices to configure the project: 

<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/23_1_VSCode_config_wizard.png" alt="drawing" width="600"/>

<BR>
   

This will configure an environment to match these choices and create the project; takes a couple minutes.


Activate the explorer by clicking the double page icon at the top of the activity bar. You should see an item corresponding to your new project. Expand this view.

<BR>
   

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/24_1_VSCode_Azure_Function_file_explorer.png" alt="drawing" width="200"/>

<BR>
   

Click on the `requirements.txt` file to see its contents. This file describes packages that are installed in a Python virtual environment 
for the Azure Function to run. A Python virtual environment is essentially a refined or 'value added' version of the basic Python environment. 


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/24_2_VSCode_requirements_dot_txt.png" alt="drawing" width="800"/>


Related: The file `pyvenv.cfg` describes the local Python executable path and version. Above in part 5 we
made sure to have Python 3.8+ 64-bit installed. 
The Python executable referenced in the `home` variable assignment in the `pyvenv.cfg` file should in fact 
be this version of Python. 


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/25_1_VSCode_Python_virtual_environment_configuration.png" alt="drawing" width="800"/>



## 7 Code break
    

[TOC](#table-of-contents)


The VSCode Sidebar provides us with a navigator for our Azure Function called `azfn`. Let's create some code in this folder.
The plan for this code is to receive an integer labeled `n` and return its prime factorization as a string; or it may also
receive a sudoku puzzle labeled `s` (and 81-character string of digits) and return a solution for that puzzle.
 
This process is
initiated by the Azure Function trigger; which we selected above to be an HTTP message. 


* In the file `__init__.py` replace the default text with the following code: 
 


```
import logging
import azure.functions as func
    
def factor_integer(n):
    if n < 4: return [n]
    prime_factors, factor_candidate = [], 2
    while factor_candidate ** 2 <= n:                        # regime of possible factors
        if n % factor_candidate:                             # here n is not divisible
            if factor_candidate == 2: factor_candidate = 3   # increase candidate factor
            else:                     factor_candidate += 2  # ...not efficient!...
        else:
            n = n / factor_candidate                 # n *is* divisible by a factor
            prime_factors.append(factor_candidate)   
    if n > 1: prime_factors.append(int(n))           # options exhausted: a residual n > 1  
                                                     #   will be the (float) last factor
    return prime_factors

    
def sudoku_solver(p):
    i = p.find('0')
    if i < 0: yield p
    else:
        for v in set('123456789')-set(p[j] for j in range(81)
            if (i%9==j%9) or (i//9==j//9) or (i//27==j//27 and i%9//3==j%9//3)):
            for s in sudoku_solver(p[:i]+v+p[i+1:]): yield s
             

def main(req: func.HttpRequest) -> func.HttpResponse:

    logging.info('Python HTTP trigger function azfn1 processed a request, hurray')
    n = req.params.get('n')
    s = req.params.get('s')
    if n:
        factor_list = factor_integer(int(n))      # gets a list of factors
        factor_string = ' * '.join([str(f) for f in factor_list])
        reply_string = 'Results: ' + str(n) + ' has ' + str(len(factor_list)) + ' factors, is = ' \
                       + factor_string + ' ... thanks for playing!'
    elif s:
        if len(s) == 81 and s.isnumeric():
            reply_string = ''
            for solution_string in sudoku_solver(s): reply_string += solution_string + '\n'
        else: reply_string = 'could not parse Sudoku puzzle string'
    else: reply_string = "no parameter parsed"

    return func.HttpResponse(reply_string, status_code = 200)
```

* Save this file
* Read through the code to discern what it does; more on this below
* From the VSCode **`Run`** menu: Start the debugger
    * This will launch the Azure Function locally on your laptop
        * As noted above: Your laptop is running a Server program on behalf of this Azure Function
    * VSCode will stay in Debug *run* mode until you stop it
    * In the course of building the Azure Function (assuming all goes well): VSCode will print a URL in the terminal window
        * For example: **`http://localhost:7071/api/HttpTrigger1`**
        * Copy-paste this URL into your browser address bar
        * This should result (assuming all goes well) in the message `no parameter parsed`


kilroy formerly `__init__.py` used the following to import from `factors.py`; fails now; why?

```
from .factors import factor_integer, sudoku_solver
```
    
kilroy what does 7071 mean?


## 8 Test locally

    
[TOC](#table-of-contents)

    
* run the Azure function with no parameters: Result is `no parameter parsed`
* add the parameter at the end of the URL: `?n=60`
* change this parameter to `?s=027800061040030008910005420500016030000970200070000096700000080006027000030480007`
    
    
When using the parameter key 'n' the Azure Function interprets the request as 'factor this integer value'. 
The key 's' is interpreted as 'solve this Sudoku puzzle'. (A zero is interpreted as a blank square in the
Sudoku puzzle. The solutions reported back have no zeroes.)
    
    


<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/27_1_VSCode_test_Azure_Function_localhost.png" alt="drawing" width="800"/>

<BR>
   
Notice that the Activity Bar context switches from Azure to Debugging. 


The term `localhost` refers to your
own computer; so this causes your browser to go to port 7071 on your own computer. This port has been associated
with your Azure Function; so it is triggered.
    
* Reverse engineering: Find `no parameter parsed` in the code


This is an example of using a browser to interact with a web service. 


Notice the **Run / bug** icon in the activity bar displays a blue badge.
This indicates the Azure Function process is running locally.
Stop the Function, clear the badge.


## 9 Deploy to Azure


[TOC](#table-of-contents)


It remains to click the *Deploy to Azure* button.
In VSCode select the Azure view as before.
Hover on **`WORKSPACE`** for the up-arrow-to-cloud icon.
Click this icon to start an upload-to-Azure wizard.


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/29_1_VSCode_deploy_button.png" alt="drawing" width="400"/>


<BR><BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/30_1_VSCode_Azure_Function_Deployment_Dialogs.png" alt="drawing" width="800"/>

<BR>

    
While the Azure Function deploys on the Azure cloud the lower console directs your attention to the **OUTPUT** tab.  
The URL of this new Azure Function appears here as a URL on **`azurewebsites.net`**.
 

The deployment will enable Application Insights by default. This is useful as it allows us to see the logging results
in the console. See first section in the Appendix below on how to do this. 


We can return to the Azure portal to see the Azure Function listed in the default Resource Group.
 
 
<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/30_2_Default_Resource_Group_shows_Azure_Function.png" alt="drawing" width="800"/>

<BR>

As we did locally we can test the Azure Function using the URL in a browser address bar.

<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/30_3_VSCode_Deployment_Output_And_Two_Browser_Tests.png" alt="drawing" width="800"/>


<BR><BR>

If this works as planned we have completed coding, testing, deploying and executing the Azure Function on the Azure cloud. 


## 10 Programmatic test


[TOC](#table-of-contents)


The final activity returns to the theme of automation. Let's execute the Azure Function trigger using Python 
rather than typing text into a browser address bar by hand. We can do this as a short three-line Python program
or by 'talking' directly to the Python interpreter. 


Ensure that the Python `requests` library is installed in your environment.
If you try to `import requests` in Python and the interpreter tells you it has 
no such library: Return to the `bash` shell and enter a
command to install `requests`. This command is `python -m pip install requests`. 
This simple program requests the factorization of an integer. Note that the URL
is the *base* URL as shown above with a key-value parameter string appended
after a question mark character `?`.


Test via a 3-line Python program...
 

```
import requests
urlbase='https://rob5azfn02.azurewebsites.net/api/HttpTrigger1'
print(requests.get(urlbase + '?n=23948237498237').text)
```

...and this can also be entered on the Python command line as shown below. 
 
To get to the Python command line from 
the `bash` prompt: type `python`. The result: A new prompt that
probably looks like `>>> `. Now instead of talking to the `bash shell`
we are talking to the Python interpreter. 

 
These commands ought to work (4/27/22). You can try them to
verify. To test your version: Replace `rob5azfn02` with your Azure function's name; and replace
`HttpTrigger1` with your trigger name (if it is different). 

```
prompt> python

Python 3.8.6 (tags/v3.8.6:db45529, Sep 23 2020, 15:52:53) [MSC v.1927 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.

>>> import requests
>>> urlbase='https://rob5azfn02.azurewebsites.net/api/HttpTrigger1'
>>> print(requests.get(urlbase + '?n=23948237498237').text)

Results: 23948237498237 has ... etcetera ... thanks for playing!

>>> 
```

This completes the activity, constructing and testing a simple serverless function on Azure. 
The first million executions of this function incur no cost. 
 
Services like this tend to be stable and "just work" for 
the foreseeable future: On the cloud typically three to five years.
But the technology continues to advance so it may be necessary to
perform an update of some sort down the road.


Real implementations will tend to be more complex. 
They will tend to involve connecting 
the serverless function with data resources. While this is 
beyond the scope of this tutorial, a vast array of instructional resources are 
available online. 

## Appendices


[TOC](#table-of-contents)
    

### Logging results in the Azure console

    
[TOC](#table-of-contents)
    
    
From Home view: Choose the Function App of interest
 
This gives the Overview view by default: emphasis on left menu bar
 
Choose Functions from this menu bar: Will list the function `HttpTrigger1` (or whatever it is named)
 
Click on that Trigger; and from the new page, at left, click Monitor
 
In the main panel of the portal/console there are two options: Invocations and Logs. Select Logs.
 
This brings up a black-background text box. Test the Azure Function to see the diagnostics printed in this text box.

 
### Serverless computing and Azure Serverless Functions

    
[TOC](#table-of-contents)
    
    
Our goal here is to create an Azure Function, an online service that factors an integer (for example). 
As no Virtual Machine is explicitly involved in this process the result is called a 'serverless function'.
This suggests visualizing cloud platforms like Azure as programmable computers.


In building research computing machinery ('infrastructure') we have options for degree of effort, cost, 
and types of interactivity with the end result. 'Serverless' is on the simple-cheap-not-very-interactive end 
of this spectrum. Serverless does away with an 'underlying computer' so it is correspondingly at the simple
end of the task pool. Serverless functions often exist as public endpoints, as 'URLs on the internet'.
That is, they can be used by collaborators or by scientists we do not know. 


If a serverless function on Azure is not built "on some virtual machine on the cloud"... where *do* we build it? 
Starting on a laptop or a desktop connected to the internet: We will describe two courses of action.  
First we use a browser to connect to a ***Cloud Portal*** which is a rather complicated interface to 
"everything" on that cloud.  Second we install an Integrated Development Environment, that is an application
that allows us to (a) build and test the Azure Function locally and (b) deploy it to the cloud where 
it 'lives and operates' on demand. This IDE is called Visual Studio Code, abbreviated VSCode.
It is available for PC, Mac and Linux operating systems at no cost.  


#### Triggers

A serverless function has a trigger: Something happens to make it run. This might be an alarm clock set 
up as a trigger. It can be a new data file arriving in a storage location, again pre-configured to act as a 
trigger. In this walk-through the trigger is an HTTP request. 


Let's break down the trigger event as two appended strings that are entered into a browser address bar. 
The first string is the URL of the Azure Function. This we are handed in the process of deploying our 
Function. The second string is a list of parameters, in our case just one parameter, that can be parsed
by the Azure Function. Here is the breakdown:

```
URL of the Azure Function is (for example): https://111.22.33.44

Parameter string to pass an integer 'n' with value 105: ?n=105

Two strings appended together, to place in browser address bar: https://111.22.33.44?n=105
```

In practice rather than an ip address like `111.22.33.44` we receive a more human-friendly URL
for our Azure function such as `https://factoring.azurewebsites.net/api/factoring`. 
On the cloud the trigger passes the parameter to the code we have emplaced. For this
code we use Python 3 split across two source code files. 

    
### Stretch Problem 1

    
[TOC](#table-of-contents)

    
Goal: Get a sense of cloud serverless function time-per-task using VSCode as a test platform. 


Step 1: Create a Client program that successfully calls the existing Azure Function
Step 2: Modify this program to call the Azure Function multiple times, timing the results
Step 3: Change the test parameters to determine what probably takes up the execution time

    
#### Step 1

    
Above we created an Azure Function
to factor an integer (passing it parameter `n`). 
The Python code used to test this was given as: 


```
import requests
urlbase='https://rob5.azurewebsites.net/api/azfn1'
print(requests.get(urlbase + '?n=144').text)
```

This can be executed one at a time using the Python command prompt `>>>` or written
into a Python program file, say named `azfunctionclient.py`. You may use VSCode for this
where it is strongly encouraged that you save the file outside the Azure Function folder. 
The procedure is to create a new file, paste in the above code, and save this file 
*as type **Python*** in a new folder, again outside the folder containing the Azure function. 
The reason for this is to keep your test client (that runs on your local machine) distinct from 
code that goes into your Azure Function.


Run the client program in VSCode using the 
*run* button (green triangle) at the upper right. Verify that the program works properly
by looking at the output in the TERMINAL window. 


#### Step 2

    

    
Modify the program to run 20 Azure Function calls and print the average time required per call.

- Add the line **`import time`** at the top of the file
    - This provides you with a timing library
- Delete the print statement (line 3 of the original program)
- Add code to run the Azure Function 20 times and determine the average time per call
    - The following code blocks can be added in sequence to accomplish this


*Block 1*
```
toc = time.time()
responses = ''
a = 1
b = 21
```

This sets up the parameters to run the Azure Function 20 times and notes the time. 


*Block 2*
```
for i in range(a, b):
    this_response = requests.get(urlbase + '?n=' + str(i)).text
    reduced_response = this_response.replace("playing!", "").replace("for","").replace("thanks","")
    responses += reduced_response.replace("...","") + '\n'    
```

This loop calls the Azure Function 20 times and gets rid of the "... thanks for playing!" message.


*Block 3*

```
tic = time.time()
elapsed_time = tic - toc
print(responses)
print("time per factorization = " + str(elapsed_time / (b-a)))
```

This notes the time again, creates a time difference and prints the average time per Azure Function call.


#### Step 3

    
If you change the range of parameters (1, 21) to much larger numbers, like (1000001, 1000021)
you have presumably made the factoring challenge more time-consuming: The algorithm has more 
work to do. However it is unclear what part of the Azure Function execution takes up how much 
time: Is it the message passing that is time consuming? Or is it the factorization? Or some
combination. 


We can start to get a handle on this by changing the nature of the task to see if this has 
a significant impact on the time elapsed. 


### Stretch Problem 2

    
[TOC](#table-of-contents)

    
The code given below was developed by Jake VanDerplas in a 
[blog about minimizing code](https://jakevdp.github.io/blog/2013/04/15/code-golf-in-python-sudoku/). 


```
def sudoku_solver(p):
    i = p.find('0')
    if i < 0: yield p
    else:
        for v in set('123456789')-set(p[j] for j in range(81)
                                      if (i%9==j%9) or (i//9==j//9)
                                      or (i//27==j//27 and i%9//3==j%9//3)):
            for s in sudoku_solver(p[:i]+v+p[i+1:]):
                yield s
```

This is Python that accepts an 81-character string as input. This
string is treated as a Sudoku puzzle to be solved. Each known value is a numeral from 1 to 9. An
open / unsolved value is a '0'. Here is an example puzzle: 

```
027800061040030008910005420500016030000970200070000096700000080006027000030480007
```


The solution is derived by dint of brute force guessing. The result is a Generator that
yields up all the solutions the solver can find. Each solution is also an 81-character
string. The two solutions to the above puzzle are 


```
327894561645132978918765423589216734463978215172543896794651382856327149231489657
327894561645132978918765423589216734463978215271543896794651382856327149132489657
```

<BR>
   
***Challenge***: Augment your Azure Function so that it can *either* factor an integer *or* 
solve a Sudoku puzzle. Here is an outline of the details:

- Add the above function to the code base
- Change the parsing logic in `__init__.py` to look for...
    - a parameter key `n`...
    - ...or failing that a parameter key `s`
        - expect the n-key value to be an integer to factor, as before
        - expect the s-key value to be an 81-character string representing a Sudoku puzzle

<BR> 

    
If the Azure Function is handed a number to factor: We get back the prime factorization.
If the Azure Function is given a Sudoku puzzle: We get back some solutions if they can be found. 


### Stretch Problem 3

    
[TOC](#table-of-contents)

    
Add a binding to an Azure Storage Account and create a very simple access example. For example
you might place a 3-value CSV file in the Storage Account and use a Azure Function parameter `i`
to choose one of those values: 

```
1, banana
2, apple
3, orange
```

Then test with `<baseurl>?i=2` and receive the reply `apple`.


### Docker review

    
[TOC](#table-of-contents)

    
While this walk-through is for Azure Functions these remarks are a short review of some key concepts
in containerization. 


- [Windows installation](https://docs.docker.com/docker-for-windows/install/)
- Download the installer, run through the installation, start the Docker app (this takes some time)
- Run through the tutoria ("2 minutes")
    - Notice this tutorial places an active Windows Powershell in the right side of the application panel
    - Running the first two commands `docker run` and `docker cp` in this shell sets in motion:
        - git clone of the github docker-org `getting-started` repo (from `alpine/git:latest`)
        - this is into `~/getting-started`
    - Next is `docker build` from the clone directory: Builds the 101 tutorial. This takes a minute.
    - Next `docker run` runs this newly built docker container, mapping port 80 of the container to port 80 of the OS. 
    - Next `docker tag` and `docker push`; so now this image is registered under my docker user account

    
Let's back up from the "docker image at Docker Hub" part: I use `localhost/tutorial` to see the tutorial web app. 
That is, a running docker container is serving HTML to my browser when I hit that localhost URL. Great; there 
ought to follow some more illumination on the `docker do-something` syntax and the Docker Windows app. 

    
Turning to that app for a moment: The `alpine/git` repo features four action icons but only two are activated: 
Start and Delete. It's status is EXITED(0). The `docker-tutorial` Docker container is RUNNING on port 80 and 
fiveicons are active: Open in browser, CLI, Stop, Restart and Delete. 

    
Clicking on the **CLI** icon gets me a shell window with a `#` prompt. So this is the Part B of the Docker
container: Not only is it "running as a program" but it also "has a shell where I am root". Here is a point of
interest: The process list command `ps -ef` turns up one `master` process, quantity eight `worker process`, 
one `sh` shell and of course `ps -ef` itself. The master and eight workers are all under the `nginx` web server. 
So that is in short the smoking gun of "what this container is doing as an exectuable program" (in addition to
running a shell). 

    
Ok so there is a Docker image out there; and a Docker executable. Is this like a JVM? Going to the executable
from the image is ... well we did a build in the tutorial so I'm voting on the JVM idea. Anyway you get
something (where is it???) and you then run it and there is your textbook quote. 


### Stretch Problem 1 example results


[TOC](#table-of-contents)


<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/31_1_Python_Azure_Function_Client_Timing_Test.png" alt="drawing" width="900"/>


<BR>

