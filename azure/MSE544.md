[TOC](#table-of-contents)

# Azure Functions: Serverless computing on the cloud

This tutorial follows a very minimalist path to a working example of serverless,
owing to time constraints. We suggest viewing this as introductory steps towards 
developing comprehensive cloud computing 'builder' skills. 


## Links


- [Shared slide presentation](https://docs.google.com/presentation/d/1R2HHfHYgmarje2q_0x42hMecUc7R6SFjI-ih1L05foQ/edit#slide=id.p) viewable by anyone
- [Padlet for communications](https://padlet.com/robfatland/serverless)
- [This walkthrough](https://github.com/robfatland/serverless/blob/main/azure/MSE544.md)


### Installation


- Install [VSCode](https://code.visualstudio.com/)
- Install the [Azure Functions **Extension** in VSCode](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions)



#### Open questions on installs


Per TA discussion on 4/20/23 we would like to understand the '...also install...' ecosystem. For students: Skip this section.


- Mac M1: Homebrew, Rosetta, Qemu x86 emulators?
- Can we consistently use Python 3.9 across local and Azure without any trouble?
- [Azure Functions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions?tabs=v4&pivots=programming-language-python) vis-a-vis runtimes
    - **`pip install azure-functions`**
- [Azure Core]
    - [**`pip install azure-core`**](https://pypi.org/project/azure-core/)
        - Idea: **`requirements.txt`** does the configuration job for the Azure Function package in the cloud
- [Python library: Azure Functions Core Tools](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local)
    - Necessary to test an Azure Function on a local machine
    - Unclear if the install is necessary; it should be bundled with the VSCode Azure Functions Extension
- Mac: Believed unnecessary: [.Net Core](https://dotnet.microsoft.com/download)


#### Reference Documentation


- [Microsoft Azure Functions overview](https://learn.microsoft.com/en-us/azure/azure-functions/)
- [Microsoft Azure Functions general structure](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference)
- [Microsoft Azure Functions specifically with Python](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python)
- [Function Apps](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings): The execution context for Azure Functions
- [YouTube video on Azure Functions](https://youtu.be/kvTostlJp7M), a very thorough (and quite rapid) presentation; recommended


#### Further reading




- [Serverless function design pattern introduction](https://www.twilio.com/docs/glossary/what-is-serverless-architecture) 
- [Using Serverless Functions for deep learning](https://www.serverless.com/blog/using-tensorflow-serverless-framework-deep-learning-image-recognition)
- [Code golf Sudoku solver blog by Jake VanDerplas](https://jakevdp.github.io/blog/2013/04/15/code-golf-in-python-sudoku/): A fun digression on compact Python coding
- [Rustem Feyzkhanov's GitHub Lambda (AWS Serverless) adaptations library](https://github.com/ryfeus/lambda-packs): Making common Python libraries 'serverless-friendly'
- [Using a NoSQL Database with Serverless Functions](https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/serverless-computing-database)



## Table of Contents


[Table of Contents (TOC)](#table-of-contents)


* [Overview](#overview)
* [1: Establish access to an Azure Subscription](#1-establish-access-to-an-azure-subscription)
* [2: Portal work](#2-portal-work)
* [3: On templates and code](#3-on-templates-and-code)
* [4: Switching to Visual Studio Code (VSCode)](#4-switching-to-visual-studio-code-vscode)
* [5: Installing Python and Extensions](#5-installing-python-and-extensions)
* [6: Creating an Azure Function in VSCode](#6-creating-an-azure-function-in-vscode)
* [7: Code break](#7-code-break)
* [8: Test locally](#8-test-locally)
* [9: Deploy to Azure](#9-deploy-to-azure)
* [10: Programmatic test](#10-programmatic-test)
* [Appendices](#appendices)
    + [Logging results in the Azure console](#logging-results-in-the-azure-console)
    + [Stretch Problem 1: Timing an Azure Function](#stretch-problem-1)
    + [Stretch Problem 2: Binding an Azure Function to a data source](#stretch-problem-2)
    + [Docker review](#docker-review)
    + [Stretch Problem 1 example results](#stretch-problem-1-example-results)



## Overview

[TOC](#table-of-contents)


This section looks at cloud thinking, cloud terminology and the road ahead. 


> Working on the cloud: Things like storage or containers or a virtual machine or an Azure Function are
> generically called **Resources**. One thing to be on the lookout for are various types of virtual boxes
> that *contain* resources; an organization mechanism. You have seen this already with Resource Groups and
> perhaps Storage Accounts. 



* Serverless computing is an important element of computing on the cloud
    * The goal is to build some simple compute functionality on the (Azure) cloud without bothering with a server
    * A server is a computer that listens for traffic and responds; it requires care and feeding
    * If we succeed: We get to skip the care and feeding part. This is '*serverless*.'
    * The serverless brand name is '**Azure Function**'. On AWS it is '**Lambda Function**'
    * Advantages: **Low hassle, Secure, Scalable, $Cheap**
    * A serverless function requires a **trigger** to start it in motion
        * Example triggers: An automated 'computer alarm clock', an HTTP web request
    * We want to notice how system feedback helps us debug
    * Serverless functions tend to do *simpler* tasks compared to what we do with *containers*


* Milestones
    - From a browser: Use the Azure Portal to create an Azure Function App
    - Configure your personal computer to be a Development Environment (already done!)
    - Build and test an Azure Function on your computer
    - Push that to the cloud and test it there


### Azure


[TOC](#table-of-contents)


* Microsoft Azure is one of the primary public clouds
    * We develop cloud content locally in **Visual Studio Code** or [VSCode](https://code.visualstudio.com/)
* Jargon: *Scalable* means that the cloud can handle large demand for this content
    * ...typically by making lots of copies of the execution environment
* Jargon: *Azure Function App* is an execution context for one or more Azure Functions
    - This is an organizing box
    - The 'Function App' can be viewed as 'An App With multiple moving parts (Functions) working together'
    - Our emphasis is more on getting a Function working; so Function App is a 'box for functions'
* Jargon: *Stateless* means that the Azure Function runs with no memory of what has happened in the past


> An **Azure Function** runs in a *one-time transaction* model; '*stateless*' (no memory of past runs) 
> However: An Azure Function can connect to persistent storage (say a database or object storage) which
> starts to look like a *state*. 


> Azure also provides an explicitly *stateful* version of Functions
> called '**Durable Functions**'.



### VSCode


**VSCode** application contains many **views** (information panels) that we manage.


- **`EXPLORER`** view shows files in a folder
- **`RUN AND DEBUG`** view 
- **`EXTENSIONS`** view 
- **`AZURE`** view shows a **`RESOURCES`** list and a **`WORKSPACE`** (sub-views)
- **`DOCKER`** view 


When the view we need is not visible: We change the view. The view selector is the vertical strip
of icons on the left edge of the VSCode application window. This is called the **Activity Bar**
and each icon is a toggle switch for its corresponding view.



> A possible point of confusion: We use the term 'serverless' to for Azure Functions.
> Azure worries about the computer host. **However** in the course of developing the Function 
> on our own laptop: We *do* need a computer host or *server*. What is that server? That server 
> *is* your laptop running a little server program, pretending to be a server in the cloud. 
> When VSCode gives us a URL that starts with **`localhost`**: That is the connection address
> to your local server.


### Additional themes, jargon, a kilroy to-do list


* Azure Function components: A storage account for what?, a code base, configuration files
* __init__.py is the *recipe* for the Azure Function; break down into components
* Security: We use *Anonymous*: Users do not need to authenticate to use a service
* Function App anatomy
    * Include Python environment and `requirements.txt`
* we would like to better understand Python interpreters and Mac compatibility
    * Python 3.9 64-bit; env vars PATH, PYTHONPATH, etc
* need a brief on HTTP GET and POST trigger types
    * `.text`; body parse; logging and bindings
    * HTTP reply back response; which we parse using our browser / eyes; or using Python code
    * Touch on other triggers: a new file in a Storage Account; a line appended to an existing file; a new entry in a database table
* security segment, particularly
    - Use of private environment variables; key vault;...
    - VSCode push to GitHub
* revisit the section on printing to logs: peer into Function execution on the cloud
* add to deck: Get help using a browser; example: **`vscode azure function <error message>`**. 


#### Serverless: What is it good for?


- wildflower data: PlanetLabs RGB+NIR images of meadows on the flanks of Mt. Rainier
- Multimedia: Transform uploaded files to a standard format
- Database quality control: Changes must meet standards
- Bounce IoT sensor input messages to actuators
- Handle high-volume data streams
- Chat bots: scaling automatically for peak demand
- Batch jobs scheduled tasks: intense parallel computation, IO or network access
- HTTP REST APIs and web apps: traditional request and response workloads
- Mobile back ends
- Business logic: orchestration of microservice workloads
- Continuous integration pipeline: remove the need for pre-provisioned hosts


## 1 Establish access to an Azure Subscription 


[TOC](#table-of-contents)


* Log in to [portal.azure.com](https://portal.azure.com) to verify your access
* You authenticate by means of your UW NetID
    * When instead we use a program to log in on our behalf: we use a different authentication method
    * kilroy maybe make a further remark on this


## 2 Portal work


[TOC](#table-of-contents)


Examine the [Azure portal](https://portal.azure.com) upper left corner: 


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_001_portal.png" alt="drawing" width="500"/>


Top row of icons includes...


- **Create a resource** is the starting point for manually getting cloud resources, also called *services*. 
- **Resource group** (abbreviated 'RG') is a virtual container (think 'project box') for related resources we use to build something with
- **Subscription** is a User account; it can contain many RGs
- **Marketplace** is a catalog of cloud resources
- **Storage account** is another organizing box: Specifically for containing various types of data storage
- **Azure Active Directory** is a tool for managing access and authentication
- **Virtual Machines** are computers: A specific and commonly used type of resource


- Type 'function' in the top search window to find **`Azure Function App`** (the execution context for Azure Functions)


<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_002_CreateFunctionAppButton.png" alt="drawing" width="200"/>
<BR>


- Select Function App. 
- Click on the **Create** button to launch a *create* wizard. 

<BR><BR>

> You can **`Delete`** this Function App whenever you like. (Don't just yet: We need it.) 
> When you Delete a Resource: You stop paying for it. Resources we start and then forget about -- that continue
> to cost money without serving any purpose -- are called cloud zombies. 


    
<BR><BR>    
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_003_CreateFunctionAppWizard1.png" alt="drawing" width="600"/>
<BR><BR>    

    

- Using your own NetID configure the first tab of the Wizard to resemble the above
    - Assign it to your Resource Group and be sure to select Python, version 3.9, and West US 2
- Click Review + create (skips the other tabs)
- Click Create

    
<BR><BR>

> This procedure (jumping to Review + create) skips intermediate tabs: Storage, Networking, Monitoring, Deployment, Tags.
> Each has a relevance so your task would be to dig in at a later time to build a more complete picture. 
> Just one example: **Tagging** associates key-value pairs that you define with the Function App. 
> Tags can be invaluable reminders for you and others about what the Function App is doing. 

<BR><BR>
    
- Verify you get this confirmation message:

    
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_005_FunctionAppDeployment.png" alt="drawing" width="600"/>
<BR><BR>
   

- To see more on this Azure Function App: Click **Go to resource**.

    
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_006_FunctionAppOverview.png" alt="drawing" width="600"/>
<BR><BR>
   

- Please note these details within this view
    - The upper left corner link returns to the Home view
    - The left sidebar title is the name of your Azure Function App: Your portal view focus
    - The scrollable left side-bar is a context menu for the many facets of the Azure Function App
        - By default *Overview* is selected: What we see in the main-central panel
    - Along the top of the main-center panels find a series of common tasks
        - **Browse**, **Refresh**, **Stop**, **Restart**, **Delete** etc
        - The Azure Function App can be turned on and off (without deleting it)
    - Right side of main panel: A URL associated with the Azure Function App

    
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_007_AzureFunctionAppURL.png" alt="drawing" width="600"/>
<BR>

    
- Paste the URL to a new browser tab to view the simple placeholder Azure Function App (below)
    - This App features a little interactivity (click the little smiley face)
- Return to the Azure Function App and navigate to **Functions** (left sidebar): No Functions are listed
    - + Create provides 3 options: VSCode, editor + Core Tools, or Develop in portal
        - You might try options 2 or 3 as a stretch goal; here we now proceed to use VSCode


## 3 On templates and code

    
[TOC](#table-of-contents)

    
> In the portal Overview view of this Azure Function App: Notice the **JSON view** link
at the upper right. Click this link to see a pop-up
text document that describes the Azure Function using a descriptive
protocol called JavaScript Object Notation (JSON). This JSON text can be used as a template
to create new Azure Function Apps, i.e. using code rather than manually. This is the 
doorway to doing your cloud-based construction from code rather than clicking on wizards.


    
## 4 Switching to Visual Studio Code (VSCode)


[TOC](#table-of-contents)


- Start **VSCode** and ensure (bottom info bar) you are logged in to Azure
- If not done already: Use the Extensions view to find and install the **Azure Functions** extension
- It often helps to stop and re-start VSCode to cause changes to take effect
 

## 5 Installing Python and Extensions

 
[TOC](#table-of-contents)
    
    
#### TA team: Skip these steps; so we can determine if any are necessary
    
    
- kilroy need to clarify whether a Python install is needed, version 3.9 64-bit etc.
    - The following is from the old version of this walkthrough:
        - 'Run the installer with defaults settings, and DO NOT SELECT "Add Python to PATH"***'
        - Stop and re-start VSCode
        - Open the command palette with ctrl+shift+p
        - Verify you have Python 3.9 64-bit installed on your development system: `python --version`
        - Update `pip` using the command `python -m pip install --upgrade pip`
        - Install the Python **requests** package:  `python -m pip install requests`
            - This enables a Python program to talk to a website
            - More accurately: The Python program can send and receive HyperText Transfer Protocol (HTTP) messages 
        - Restart ***VSCode*** and sign in to Azure
            - On the Terminal type `az login`: This should launch NetID authentication
            - Verify: Click the Azure icon on the Activity Bar (stylized **A**) and check the status bar (bottom)
        - Install *Azure Functions Core Tools* 
            - Use [this URL](https://github.com/Azure/azure-functions-core-tools#installing)
        - To see if it installed: From within VSCode
            - Activity Bar (vertical icon bar at the far left) select Extensions icon
            - Search for Azure Functions Core Tools
        - Mac Users: It may be helpful to [install **.Net Core**](https://dotnet.microsoft.com/download)


## 6 Creating an Azure Function in VSCode


[TOC](#table-of-contents)

    
- VSCode starts with a tabbed Welcome page. Dismiss this page to show some Ctrl-key shortcuts
    - Use ctrl + shift + p to bring up command options
    - Choose **`Python: Select interpreter`**
    - Choose Python 3.9
- The VSCode console layout includes an **Activity Bar** at the extreme left (vertical sequence of icons)
    - Also on the left side of VSCode is a second **Sidebar** with one or more information panels
    - Your **Activity Bar** selection will determine the view in the **Sidebar**.
- At the bottom of the VSCode console is a status bar. 
    - Select the Azure icon in the Activity Bar
    - You should see your Azure sign-in status in the status bar: `Azure:yourNetID@uw.edu`*
    - If you are not signed in to Azure 
        - ctrl + shift + p to bring up the command options 
        - Type `Azure Sign In` at the prompt and select this option 
        - Authenticate and verify the status bar

    
<BR><BR>
> While you are authenticated into Azure, the VSCode app is running on your laptop; 
> so there is a 'here' and a 'there'. 'Here' is your laptop VSCode app and 'there' is 
> the Azure cloud. 
<BR><BR>
    
    
- Use ctrl + j to bring up a tabbed console in the lower part of the VSCode main window.
- Toggle on the Azure icon in the activity bar. 
    - Note the RESOURCES and WORKSPACE panels in the sidebar
    - If these are not visible use the **`...`** dropdown menu at the upper right to select them

    
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_004_VSCodeAzureView.png" alt="drawing" width="500"/>
<BR>
    

- Build an Azure Function locally, on your computer ('here').     
    - Hover your cursor over the **WORKSPACE** panel to bring up a context menu at the upper right
    - Click on the +-lightning-bolt (Create Function) icon in this menu
        - Use `browse...` to create a host folder `azurefunction` and select this as your working location
        - Make the following choices to configure the project

    
<BR>
<BR>   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_009_FunctionBuildChoices.png" alt="drawing" width="500"/>
<BR>
<BR>
   
- Confirm you trust the authors; there should now be a **`Local Project`** folder in your WORKSPACE panel
    - Expand this folder and note that there is a list of Functions but no Function App
    - Under Functions is the function you just defined, with `HTTP` indicating its trigger type
    - Click on this function to see how it is represented as the JSON file `function.json`
- In VSCode activate the EXPLORER view (Double page icon at the top of the Activity Bar) 
    - Open / expand the view of the Azure Function in the UNTITLED (WORKSPACE)
    - Locate and click on the file **`__init__.py`** to open it in an editor

<BR><BR>

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_010_Project.png" alt="drawing" width="200"/>

<BR>
<BR>
> The file `requirements.txt` describes packages installed in a Python virtual environment 
<BR>
<BR>


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_011_Requirements.png" alt="drawing" width="500"/>

<BR>
<BR>

> Related: The file `pyvenv.cfg` describes the local Python executable path and version. Above in part 5 we
made sure to have Python 3.8+ 64-bit installed. 
The Python executable referenced in the `home` variable assignment in the `pyvenv.cfg` file should in fact 
be this version of Python. 
<BR>
<BR>


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_012_Pyvenv.png" alt="drawing" width="500"/>



## 7 Code break
    

[TOC](#table-of-contents)


- Above: Explorer view shows the project files for the Azure Function `azurefunction`
    - Next is to modify the code that runs when `azurefunction` is triggered
        - We will permit two options: One to factor an integer, one to solve a Sudoku puzzle
        - These will correspond to keys `n` and `s` respectively
- In the file `__init__.py` replace the default code with the following: 
 


```
import logging
import azure.functions as func
    
def factor_integer(n):
    if n < 4: return [n]
    prime_factors, factor_candidate = [], 2
    while factor_candidate ** 2 <= n:                        # regime of possible factors
        if n % factor_candidate:                             # non-divisible: remainder evaluates as True
            if factor_candidate == 2: factor_candidate = 3   # increase candidate factor
            else:                     factor_candidate += 2  # ...not efficient!...
        else:
            n = n / factor_candidate                 # reduce n by this factor
            prime_factors.append(factor_candidate)   
    if n > 1: prime_factors.append(int(n))           # final factor (unless it is 1)
    return prime_factors

    
def sudoku_solver(p):
    i = p.find('0')
    if i < 0: yield p
    else:
        for v in set('123456789')-set(p[j] for j in range(81)
            if (i%9==j%9) or (i//9==j//9) or (i//27==j//27 and i%9//3==j%9//3)):
            for s in sudoku_solver(p[:i]+v+p[i+1:]): yield s
             

def main(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Just imagine! An HTTP trigger ran this Azure Function!')
    n = req.params.get('n')
    s = req.params.get('s')
    if n:
        factor_list = factor_integer(int(n))      # gets a list of factors
        factor_string = ' * '.join([str(f) for f in factor_list])
        reply_string = 'Results: ' + str(n) + ' has ' + str(len(factor_list)) + ' factors, is = ' \
                       + factor_string + ' ... thanks for playing!'
    elif s:
        if len(s) == 81 and s.isnumeric():
            reply_string = ''
            for solution_string in sudoku_solver(s): reply_string += solution_string + '\n'
        else: reply_string = 'could not parse Sudoku puzzle string'
    else: reply_string = "no parameter parsed"

    return func.HttpResponse(reply_string, status_code = 200)
```

* Save this new version of `__init__.py`
    * Optional: Read through the code to decode what it does
* From the VSCode **`Run`** menu: Start the debugger
    * You may need to confirm that you trust the publisher (you)
    * This will launch this Azure Function locally on your laptop
        * Your laptop is running a Server on behalf of this Azure Function
    * Upon finishing the build: 
        * VSCode tends to put your tabbed console in `DEBUG CONSOLE` mode
        * Switch it to `TERMINAL` view
        * Here you should see some messages including a URL
            * For example: **`http://localhost:7071/api/azurefunction`**
            * `localhost` is your computer. 
            * `7071` is a **port** or a *dedicated communication channel*. 
        * Copy-paste this URL from VSCode into your browser address bar
        * This should result in the message `no parameter parsed`
* VSCode will stay in Debug *run* mode until you stop it

    
> The code in the Python file **`__init__.py`** consists of four sections:
> - import libraries
> - a function **`factor_integer()`**: factors an integer into prime factors
> - a function **`sudoku_solver`**: solves a Sudoku puzzle
> - main: receive the HTTP request and responds to it

    
## 8 Test locally

    
[TOC](#table-of-contents)

    
* run the Azure function with no parameters: Result is `no parameter parsed`
* add the parameter at the end of the URL: `?n=60`
* change this parameter to `?s=027800061040030008910005420500016030000970200070000096700000080006027000030480007`
    
    
When using the parameter key 'n' the Azure Function interprets the request as 'factor this integer value'. 
The key 's' is interpreted as 'solve this Sudoku puzzle'. The puzzle consists of a string of 81 digits.
A zero digit means that square begins as blank. When the solver is successful: All the zeros are replaced
by other digits.
    
    


<BR>
<BR>   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/27_1_VSCode_test_Azure_Function_localhost.png" alt="drawing" width="800"/>
<BR>
<BR>  


> Notice the **Run / bug** icon in the activity bar displays a blue badge.
This indicates the Azure Function process is running locally.
Stop the Function and this will clear the badge.


## 9 Deploy to Azure


[TOC](#table-of-contents)


> To deploy the Azure Function to the cloud we need an Azure Function App. 
> We created one of these in the Portal activity above. 
    
  
- In VSCode select the Azure view
    
<BR>
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_008_UploadFunction.png" alt="drawing" width="100"/>
<BR>
<BR> 
- Place your cursor inside the **`WORKSPACE`** panel and select **`Deploy...`** (icon above)
    - Select **`Deploy to Function App`**
    - Select the folder for your Azure Function
    - Select the Azure Function App built earlier via the portal
    - Confirm the Deploy action
    - Note the publication URL and paste this into a browser address bar
    - Test the Azure Function using the factoring (`?n=2342`) and Sudoku tests as above

  
<BR><BR>    
> The deployment will enable Application Insights by default. 
This is a service that gives us access to logging results
in the console. 
<BR><BR>    
  
> We can go to the Azure portal (web browser) 
to confirm the Azure Function appears in the Azure Function App.
<BR><BR>

## 10 Programmatic test


[TOC](#table-of-contents)


Next we run the Azure Function from Python. This requires about four lines of Python code. 


    
kilroy which interpreter... do students need to `python -m pip install requests` in some manner?

    

The code below sends an HTTP message to your Azure Function, gets 
a reply, and prints the text of that reply. 
    
    
```
import requests
urlbase='https://rob5-function-app.azurewebsites.net/api/function1_vscode_http_trigger'
full_url = urlbase + '?n=23948'
print(requests.get(full_url).text)
```


    
There are a couple ways to run this code. You can start the Python interpreter
by typing `python` at the command prompt. This gives you the Python prompt `>>> `. 
You can then copy-paste the code one line at a time. 
You can stop Python interpreter by typing `exit()`.

    
As an alternative you can save this code as a file 
with a name like `testFunction.py`; then run the file from the bash command line: 
`python testFunction.py`.


This completes constructing and testing a simple serverless function on Azure. 
The first million-or-so executions of this function incur no cost.


Azure Functions tend to involve connecting 
the serverless function to data resources. While this is 
beyond the scope of this tutorial, a vast array of instructional resources are 
available online. A reasonable project might be to construct a small table
of key-value pairs, place that table into a NoSQL serverless database 
(on Azure this is called **`CosmosDB`**) and use your Azure Function to
retrieve data from that table. See 'stretch problem 2' below for more on this.


## Appendices


[TOC](#table-of-contents)
    

### Logging results in the Azure console

    
[TOC](#table-of-contents)
    
    
- Azure portal Home view: Choose the Function App of interest
    - This gives the Overview view by default: see the emphasis on left menu bar
- Choose Functions from this menu bar to list the function `HttpTrigger1` (or whatever it is named)
- Click on that Trigger; and from the new page, at left, click Monitor
- In the main panel of the portal/console select Logs
    - This brings up a black-background text box
    - Test the Azure Function to see diagnostics printed in this text box
        - Notice that the diagnostics text connects back to the Azure Function code
        - This is a debugging pathway: Your Azure Function can tell you what it thinks is going on.


#### Triggers

A serverless function has a trigger: Something happens to make it run. This might be an alarm clock set 
up as a trigger. It can be a new data file arriving in a storage location, again pre-configured to act as a 
trigger. In this walk-through the trigger is an HTTP request. 


Let's break down the trigger event as two appended strings that are entered into a browser address bar. 
The first string is the URL of the Azure Function. This we are handed in the process of deploying our 
Function. The second string is a list of parameters, in our case just one parameter, that can be parsed
by the Azure Function. Here is the breakdown:

```
URL of the Azure Function is (for example): https://111.22.33.44

Parameter string to pass an integer 'n' with value 105: ?n=105

Two strings appended together, to place in browser address bar: https://111.22.33.44?n=105
```

In practice rather than an ip address like `111.22.33.44` we receive a more human-friendly URL
for our Azure function such as `https://factoring.azurewebsites.net/api/factoring`. 
On the cloud the trigger passes the parameter to the code we have emplaced. For this
code we use Python 3 split across two source code files. 

    
### Stretch Problem 1

    
[TOC](#table-of-contents)

    
Goal: Measure Azure Function time-per-task from VSCode. 


- Create a Client program that calls the Azure Function
- Call the Azure Function multiple times: timing the results
- Investigate: What consumes the execution time: The task or the network traffic?

    
#### Create a Client


```
import requests
urlbase='https://rob5.azurewebsites.net/api/azfn1'
print(requests.get(urlbase + '?n=144').text)
```

This can be executed one at a time using the Python command prompt `>>>` or written
into a Python program file, say named `azfunctionclient.py`. You may use VSCode for this
where it is strongly encouraged that you save the file outside the Azure Function folder. 
The procedure is to create a new file, paste in the above code, and save this file 
*as type **Python*** in a new folder, again outside the folder containing the Azure function. 
The reason for this is to keep your test client (that runs on your local machine) distinct from 
code that goes into your Azure Function.


Run the client program in VSCode using the 
*run* button (green triangle) at the upper right. Verify that the program works properly
by looking at the output in the TERMINAL window. 


#### Step 2

    

    
Modify the program to run 20 Azure Function calls and print the average time required per call.

- Add the line **`import time`** at the top of the file
    - This provides you with a timing library
- Delete the print statement (line 3 of the original program)
- Add code to run the Azure Function 20 times and determine the average time per call
    - The following code blocks can be added in sequence to accomplish this


*Block 1*
```
toc = time.time()
responses = ''
a = 1
b = 21
```

This sets up the parameters to run the Azure Function 20 times and notes the time. 


*Block 2*
```
for i in range(a, b):
    this_response = requests.get(urlbase + '?n=' + str(i)).text
    reduced_response = this_response.replace("playing!", "").replace("for","").replace("thanks","")
    responses += reduced_response.replace("...","") + '\n'    
```

This loop calls the Azure Function 20 times and gets rid of the "... thanks for playing!" message.


*Block 3*

```
tic = time.time()
elapsed_time = tic - toc
print(responses)
print("time per factorization = " + str(elapsed_time / (b-a)))
```

This notes the time again, creates a time difference and prints the average time per Azure Function call.


#### Step 3

    
If you change the range of parameters (1, 21) to much larger numbers, like (1000001, 1000021)
you have presumably made the factoring challenge more time-consuming: The algorithm has more 
work to do. However it is unclear what part of the Azure Function execution takes up how much 
time: Is it the message passing that is time consuming? Or is it the factorization? Or some
combination. 


We can start to get a handle on this by changing the nature of the task to see if this has 
a significant impact on the time elapsed.  


### Stretch Problem 2

    
[TOC](#table-of-contents)

    
Add a binding to an Azure Storage Account and create a very simple access example. For example
you might place a 3-value CSV file in the Storage Account and use a Azure Function parameter `i`
to choose one of those values: 

```
1, banana
2, apple
3, orange
```

Then test with `<baseurl>?i=2` and receive the reply `apple`.

    
kilroy this needs more elaboration
    


### Docker review

    
[TOC](#table-of-contents)

    
While this walk-through is for Azure Functions these remarks are a short review of some key concepts
in containerization. 


- [Windows installation](https://docs.docker.com/docker-for-windows/install/)
- Download the installer, run through the installation, start the Docker app (this takes some time)
- Run through the tutoria ("2 minutes")
    - Notice this tutorial places an active Windows Powershell in the right side of the application panel
    - Running the first two commands `docker run` and `docker cp` in this shell sets in motion:
        - git clone of the github docker-org `getting-started` repo (from `alpine/git:latest`)
        - this is into `~/getting-started`
    - Next is `docker build` from the clone directory: Builds the 101 tutorial. This takes a minute.
    - Next `docker run` runs this newly built docker container, mapping port 80 of the container to port 80 of the OS. 
    - Next `docker tag` and `docker push`; so now this image is registered under my docker user account

    
Let's back up from the "docker image at Docker Hub" part: I use `localhost/tutorial` to see the tutorial web app. 
That is, a running docker container is serving HTML to my browser when I hit that localhost URL. Great; there 
ought to follow some more illumination on the `docker do-something` syntax and the Docker Windows app. 

    
Turning to that app for a moment: The `alpine/git` repo features four action icons but only two are activated: 
Start and Delete. It's status is EXITED(0). The `docker-tutorial` Docker container is RUNNING on port 80 and 
fiveicons are active: Open in browser, CLI, Stop, Restart and Delete. 

    
Clicking on the **CLI** icon gets me a shell window with a `#` prompt. So this is the Part B of the Docker
container: Not only is it "running as a program" but it also "has a shell where I am root". Here is a point of
interest: The process list command `ps -ef` turns up one `master` process, quantity eight `worker process`, 
one `sh` shell and of course `ps -ef` itself. The master and eight workers are all under the `nginx` web server. 
So that is in short the smoking gun of "what this container is doing as an exectuable program" (in addition to
running a shell). 

    
Ok so there is a Docker image out there; and a Docker executable. Is this like a JVM? Going to the executable
from the image is ... well we did a build in the tutorial so I'm voting on the JVM idea. Anyway you get
something (where is it???) and you then run it and there is your textbook quote. 


### Stretch Problem 1 example results


[TOC](#table-of-contents)


<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/31_1_Python_Azure_Function_Client_Timing_Test.png" alt="drawing" width="900"/>


<BR>

    
### Create an Azure Function App from VSCode 
    
- In VSCode select the Azure view
- In **`RESOURCES`** expand the Subscription (gold key icon)
- From here expand the **`Function App`** category (lightning bolt icon)
- Right click on **`Function App`** and select **`Create Function App in Azure`**
    - Provide a unique name
    - Choose Python 3.9
    - Choose West US 2 as the location
        - This may produce a 'No permission message'; if so: Select Existing
    - Select the available Resource Group
    - The creation process takes a minute
    - A URL is assigned to your new Function App
