[TOC](#table-of-contents)

# Azure Functions: Serverless computing on the cloud

This tutorial follows a very minimalist path to a working example of serverless,
owing to time constraints. We suggest viewing this as introductory steps towards 
developing comprehensive cloud computing 'builder' skills. 


## Links


- kilroy pdf Luna [Slide presentation](https://docs.google.com/presentation/d/1R2HHfHYgmarje2q_0x42hMecUc7R6SFjI-ih1L05foQ/edit#slide=id.p)
- [Padlet for communications](https://padlet.com/robfatland/serverless)
- [This walkthrough](https://github.com/robfatland/serverless/blob/main/azure/MSE544.md)


### Installation


- Install [VSCode](https://code.visualstudio.com/)
- Install the [Azure Functions **Extension** in VSCode](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions)



#### Open questions on installs


Per TA discussion on 4/20/23 we would like to understand the '...also install...' ecosystem. For students: Skip this section for now.


- Mac M1: Homebrew, Rosetta, Qemu x86 emulators?
- [Azure Functions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-versions?tabs=v4&pivots=programming-language-python) vis-a-vis runtimes
    - **`pip install azure-functions`**
- [Azure Core]
    - [**`pip install azure-core`**](https://pypi.org/project/azure-core/)
        - Idea: **`requirements.txt`** does the configuration job for the Azure Function package in the cloud
- [Python library: Azure Functions Core Tools](https://learn.microsoft.com/en-us/azure/azure-functions/functions-run-local)
    - Necessary to test an Azure Function on a local machine
    - Unclear if the install is necessary; it should be bundled with the VSCode Azure Functions Extension
- Mac: Believed unnecessary: [.Net Core](https://dotnet.microsoft.com/download)


#### Reference Documentation


- [Microsoft Azure Functions overview](https://learn.microsoft.com/en-us/azure/azure-functions/)
- [Microsoft Azure Functions general structure](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference)
- [Microsoft Azure Functions specifically with Python](https://docs.microsoft.com/en-us/azure/azure-functions/functions-reference-python)
- [Function Apps](https://learn.microsoft.com/en-us/azure/azure-functions/functions-how-to-use-azure-function-app-settings): The execution context for Azure Functions
- [YouTube video on Azure Function best practices (and more)](https://youtu.be/kvTostlJp7M) kilroy check


#### Further reading




- [Serverless function design pattern introduction](https://www.twilio.com/docs/glossary/what-is-serverless-architecture) kilroy check
- [Using Serverless Functions for deep learning](https://www.serverless.com/blog/using-tensorflow-serverless-framework-deep-learning-image-recognition) kilroy
- [Code golf Sudoku solver blog by Jake VanDerplas](https://jakevdp.github.io/blog/2013/04/15/code-golf-in-python-sudoku/) 
- [Rustem Feyzkhanov's GitHub Lambda (AWS Serverless) adaptations library](https://github.com/ryfeus/lambda-packs) 



## Table of Contents


[Table of Contents (TOC)](#table-of-contents)


* [Overview](#overview)
* [1: Establish access to an Azure Subscription](#1-establish-access-to-an-azure-subscription)
* [2: Portal work](#2-portal-work)
* [3: On templates and code](#3-on-templates-and-code)
* [4: Switching to Visual Studio Code (VSCode)](#4-switching-to-visual-studio-code-vscode)
* [5: Installing Python and Extensions](#5-installing-python-and-extensions)
* [6: Creating an Azure Function in VSCode](#6-creating-an-azure-function-in-vscode)
* [7: Code break](#7-code-break)
* [8: Test locally](#8-test-locally)
* [9: Deploy to Azure](#9-deploy-to-azure)
* [10: Programmatic test](#10-programmatic-test)
* [Appendices](#appendices)
    + [Logging results in the Azure console](#logging-results-in-the-azure-console)
    + [Stretch Problem 1: Timing an Azure Function](#stretch-problem-1)
    + [Stretch Problem 2: Binding an Azure Function to a data source](#stretch-problem-2)
    + [Docker review](#docker-review)
    + [Stretch Problem 1 example results](#stretch-problem-1-example-results)



## Overview

[TOC](#table-of-contents)


This section looks at cloud thinking, cloud terminology and the road ahead. 


> Working on the cloud: Things like storage or containers or a virtual machine or an Azure Function are
> generically called **Resources**. One thing to be on the lookout for are various types of virtual boxes
> that *contain* resources; an organization mechanism. You have seen this already with Resource Groups and
> perhaps Storage Accounts. 



Let's begin by defining *serverless computing* in more detail.


* Serverless computing is an important element of computing on the cloud
    * The goal is to build some simple compute functionality on the (Azure) cloud without bothering with a server
    * A server is a computer that listens for traffic and responds; it requires care and feeding
    * If we succeed: We get to skip the care and feeding part. This is '*serverless*.'
    * The serverless brand name is '**Azure Function**'. On AWS it is '**Lambda Function**'
    * Advantages: **Low hassle, Secure, Scalable, $Cheap**
    * A serverless function requires a **trigger** to start it in motion
        * Example triggers: An automated 'computer alarm clock', an HTTP web request
    * We want to notice how system feedback helps us debug
    * Serverless functions tend to do *simpler* tasks compared to what we do with *containers*


* Milestones
    - From a browser: Use the Azure Portal to create an Azure Function App
    - Configure your personal computer to be a Development Environment (already done!)
    - Build and test an Azure Function on your computer
    - Push that to the cloud and test it there


### Azure


[TOC](#table-of-contents)


* Microsoft Azure is one of the primary public clouds
    * We develop cloud content locally in **Visual Studio Code** or [VSCode](https://code.visualstudio.com/)
* Jargon: *Scalable* means that the cloud can handle large demand for this content
    * ...typically by making lots of copies of the execution environment
* Jargon: *Azure Function App* is an execution context for one or more Azure Functions
    - This is an organizing box
    - The 'Function App' can be viewed as 'An App With multiple moving parts (Functions) working together'
    - Our emphasis is more on getting a Function working; so Function App is a 'box for functions'
* Jargon: *Stateless* means that the Azure Function runs with no memory of what has happened in the past


> An **Azure Function** runs in a *one-time transaction* model; '*stateless*' (no memory of past runs) 
> However: An Azure Function can connect to persistent storage (say a database or object storage) which
> starts to look like a *state*. 


> Azure also provides an explicitly *stateful* version of Functions
> called '**Durable Functions**'.



### VSCode


**VSCode** application contains many **views** (information panels) that we manage.


- **`EXPLORER`** view shows files in a folder
- **`RUN AND DEBUG`** view 
- **`EXTENSIONS`** view 
- **`AZURE`** view shows a **`RESOURCES`** list and a **`WORKSPACE`** (sub-views)
- **`DOCKER`** view 


When the view we need is not visible: We change the view. The view selector is the vertical strip
of icons on the left edge of the VSCode application window. This is called the **Activity Bar**
and each icon is a toggle switch for its corresponding view.



> A possible point of confusion: We use the term 'serverless' to for Azure Functions.
> Azure worries about the computer host. **However** in the course of developing the Function 
> on our own laptop: We *do* need a computer host or *server*. What is that server? That server 
> *is* your laptop running a little server program, pretending to be a server in the cloud. 
> When VSCode gives us a URL that starts with **`localhost`**: That is the connection address
> to your local server.


### Additional themes and jargon


* Azure Function components: A storage account, a code base, some configuration files
* __init__.py is the *recipe* for the Azure Function.
* Security: We use *Anonymous*: Users do not need to authenticate to use a service
* Python environments exist and are configured here via a file `requirements.txt`
* kilroy do we need to discuss WSL and Mac and Linux and Python 3.8+ 64-bit and env vars PATH, PYTHONPATH?
* kilroy develop a little bit more about HTTP GET and POST trigger types (`.text`, body parse etc)
* The Azure Functions we build reply back via HTTP response; which we parse using our browser / eyes; or using Python code
    * kilroy Other triggers? a new file in a Storage Account; a line appended to an existing file; a new entry in a database table
* kilroy a bit more about security needed, particularly
    - kilroy Private environment variables; key vault;...
    - kilroy ow to get code to GitHub from VSCode
* Debugging: Notice the exotic print statement in the code below: Where do we go to find this?
    - The implication is how to peer into Function execution on the cloud
- Get help by pasting in the browser **`vscode azure function <error message>`**. 


#### Serverless: What is it good for?


- kilroy wildflowers
- Multimedia: Transform a file upload to a standard format
- Database changes / data capture: check that the changes meet quality standards
- Bounce IoT sensor input messages to actuators
- Handle high-volume data streams
- Chat bots: scaling automatically for peak demand
- Batch jobs scheduled tasks: intense parallel computation, IO or network access
- HTTP REST APIs and web apps: traditional request and response workloads
- Mobile back ends
- Business logic: orchestration of microservice workloads
- Continuous integration pipeline: remove the need for pre-provisioned hosts


## 1 Establish access to an Azure Subscription 


[TOC](#table-of-contents)


* Log in to [portal.azure.com](https://portal.azure.com) to verify your access
* You authenticate by means of your UW NetID
    * When instead we use a program to log in on our behalf: we use a different authentication method
    * kilroy maybe make a further remark on this


## 2 Portal work


[TOC](#table-of-contents)


Examine the [Azure portal](https://portal.azure.com) upper left corner: 



<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_001_portal.png" alt="drawing" width="500"/>


Top row...


- **Create a resource** is the starting point for manually getting cloud resources, also called *services*. 
- **Resource group** (abbreviated 'RG') is a virtual container (think 'project box') for related resources we use to build something with
- **Subscription** is a User account; it can contain many RGs
- **Marketplace** is a catalog of cloud resources
- **Storage account** is another organizing box: Specifically for containing various types of data storage
- **Azure Active Directory** is a tool for managing access and authentication
- **Virtual Machines** are computers: A specific and commonly used type of resource


Type 'function' in the top search window to find **`Azure Function App`** (the execution context for Azure Functions)


<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_002_CreateFunctionAppButton.png" alt="drawing" width="200"/>
<BR>


Select Function App. Click on the **Create** button to launch a *create* wizard. 
This Azure Function App has a URL but aside from its 'hello world' value we do not care.

On **Resource Management**: You can **`Delete`** this Function App if you want to. 
When you do that: You stop paying for it. Resources that we start and then forget about, that continue
to cost money without serving any purpose, are called cloud zombies. 


    
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_003_CreateFunctionAppWizard1.png" alt="drawing" width="500"/>
    

- Using your own NetID configure the first tab of the Wizard to resemble the above
- Click Review + create (skips the other tabs)
- Click Create


- kilroy remark on skipped tabs storage networking monitoring deployment and tags
    - **Tagging**: Annotate a resource (an Azure Function App) using key-value pairs 
        - Four months interruption rule: What was I doing here??? 

    
If all goes well we get this confirmation message:

<BR><BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_005_FunctionAppDeployment.png" alt="drawing" width="600"/>

<BR><BR>
   

- To see more on this Azure Function App: Click **Go to resource**.

    
<BR><BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_006_FunctionAppOverview.png" alt="drawing" width="600"/>
<BR><BR>
   

- Please note these details within this view
    - The upper left corner link returns to the Home view
    - The left sidebar title is the name of your Azure Function App: Your portal view focus
    - The scrollable left side-bar is a context menu for the many facets of the Azure Function App
        - By default *Overview* is selected: What we see in the main-central panel
    - Along the top of the main-center panels find a series of common tasks
        - **Browse**, **Refresh**, **Stop**, **Restart**, **Delete** etc
        - The Azure Function App can be turned on and off (without deleting it)
    - Right side of main panel: A URL associated with the Azure Function App

<BR>

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_007_AzureFunctionAppURL.png" alt="drawing" width="600"/>

<BR>

- Paste the URL to a new browser tab to arrive at a simple placeholder for your Azure Function App, as shown above
    - It even features a little bit of interactive functionality (click the little smiley face)
- Return to the Azure Function App and navigate to **Functions** (left sidebar): Notice there are no Functions listed
    - If we try to create a Function here: The portal advises us to go install and use VSCode


## 3 On templates and code

    
[TOC](#table-of-contents)

    
In the portal Overview view of this Azure Function App: Notice the **JSON view** link
at the upper right. Click this link to see a pop-up
text document that describes the Azure Function using a descriptive
protocol called JavaScript Object Notation (JSON). This JSON text can be used as a template
to create new Azure Function Apps, i.e. using code rather than manually. This is the 
doorway to doing your cloud-based construction from code rather than clicking on wizards.


    
## 4 Switching to Visual Studio Code (VSCode)


[TOC](#table-of-contents)


- Start **VSCode** and ensure (bottom info bar) you are logged in to Azure
- If not done already: Use the Extensions view to find and install the **Azure Functions** extension
- ***kilroy here and what follows clarify Python install/version needs... 3.9.12???***
    - ***kilroy residual note: IMPORTANT: Run the installer with defaults settings, and DO NOT SELECT "Add Python to PATH"***
    - Stop and re-start VSCode
- Open the command palette with ctrl+shift+p
- Run the "Python: Select interpreter" command

    
- kilroy can probably delete these two bullets: 
    - Create a new Azure function from scratch per the tutorial instructions below 
    - When it comes to selecting a Python interpreter for the virtual environment choose "py -3.9"

    
## 5 Installing Python and Extensions

 
[TOC](#table-of-contents)

* kilroy As above: What of this is needed????
    
    
* Verify you have Python 3.8+ 64-bit installed on your development system: `python --version`
* Update `pip` using the command `python -m pip install --upgrade pip`
* Install the Python **requests** package:  `python -m pip install requests`
    * This enables a Python program to talk to a website
    * More accurately: The Python program can send and receive HyperText Transfer Protocol (HTTP) messages 
* Start ***VSCode*** and sign in to Azure
    * On the Terminal type `az login`: This should launch NetID authentication
    * Verify: Click the Azure icon on the Activity Bar (stylized **A**) and check the status bar (bottom)
* Install *Azure Functions Core Tools* 
    * Use [this URL](https://github.com/Azure/azure-functions-core-tools#installing)
    * To see if it installed: From within VSCode
        * Activity Bar (vertical icon bar at the far left) select Extensions icon
        * Search for Azure Functions Core Tools
    * Mac Users: It may be helpful to [install **.Net Core**](https://dotnet.microsoft.com/download)


## 6 Creating an Azure Function in VSCode


[TOC](#table-of-contents)

    
- VSCode starts with a tabbed Welcome page. Dismiss this page to show some Ctrl-key shortcuts. 
- The VSCode console layout includes an **Activity Bar** at the extreme left (vertical sequence of icons)
    - Also on the left side is a **Sidebar** with one or more information panels
    - Your **Activity Bar** selection will determine the view in the **Sidebar**.
- At the bottom of the VSCode console is a status bar. 
    - Select the Azure icon in the Activity Bar
    - You should see your Azure sign-in status in the status bar: `Azure:yourNetID@uw.edu`*
    - If you are not signed in to Azure 
        - ctrl + shift + p to bring up a little Command prompt window with options 
        - Type `Azure Sign In` at the prompt and select this option 
        - Authenticate and check the status bar
    
> While you are authenticated into Azure, the VSCode app is running on your laptop; 
> so there is a 'here' and a 'there'. 'Here' is your laptop VSCode app and 'there' is 
> the Azure cloud. 

    
- Use ctrl + j to bring up a tabbed console in the lower part of the VSCode main window.
- Toggle on the Azure icon in the activity bar. 
    - Note the RESOURCES and WORKSPACE panels in the sidebar
    - If these are not visible use the **`...`** dropdown menu at the upper right to select them

    
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_004_VSCodeAzureView.png" alt="drawing" width="500"/>
<BR>
    

We commence to build and test an Azure Function locally, on our own computer ('here'). 
    
- Hover your cursor over the **WORKSPACE** panel to bring up a context menu at the upper right
- Click on the +-lightning-bolt (Create Function) icon in this menu
    - Create the host folder and make the following choices to configure the project: 
   
    
    
- kilroy Python 3.8???
- kilroy better function name
    
    
<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/23_1_VSCode_config_wizard.png" alt="drawing" width="600"/>

<BR>
   

- This will configure an environment to match these choices and create the project; requires a couple minutes.
- Activate the EXPLORER panel: Double page icon at the top of the Activity Bar. 
- Open / expand the view of your new project folder

<BR>

<img src="https://github.com/robfatland/serverless/blob/main/azure/images/24_1_VSCode_Azure_Function_file_explorer.png" alt="drawing" width="200"/>

<BR>
   

Click on the `requirements.txt` file to see its contents. This file describes packages that are installed in a Python virtual environment 
for the Azure Function to run. A Python virtual environment is essentially a refined or 'value added' version of the basic Python environment. 


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/24_2_VSCode_requirements_dot_txt.png" alt="drawing" width="800"/>


Related: The file `pyvenv.cfg` describes the local Python executable path and version. Above in part 5 we
made sure to have Python 3.8+ 64-bit installed. 
The Python executable referenced in the `home` variable assignment in the `pyvenv.cfg` file should in fact 
be this version of Python. 


<img src="https://github.com/robfatland/serverless/blob/main/azure/images/25_1_VSCode_Python_virtual_environment_configuration.png" alt="drawing" width="800"/>



## 7 Code break
    

[TOC](#table-of-contents)


The VSCode Sidebar provides us with a navigator for our Azure Function called `azfn`. Let's create some code in this folder.
The plan for this code is to receive an integer labeled `n` and return its prime factorization as a string; or it may also
receive a sudoku puzzle labeled `s` (and 81-character string of digits) and return a solution for that puzzle.
 
This process is
initiated by the Azure Function trigger; which we selected above to be an HTTP message. 


* In the file `__init__.py` replace the default text with the following code: 
 


```
import logging
import azure.functions as func
    
def factor_integer(n):
    if n < 4: return [n]
    prime_factors, factor_candidate = [], 2
    while factor_candidate ** 2 <= n:                        # regime of possible factors
        if n % factor_candidate:                             # here n is not divisible
            if factor_candidate == 2: factor_candidate = 3   # increase candidate factor
            else:                     factor_candidate += 2  # ...not efficient!...
        else:
            n = n / factor_candidate                 # n *is* divisible by a factor
            prime_factors.append(factor_candidate)   
    if n > 1: prime_factors.append(int(n))           # options exhausted: a residual n > 1  
                                                     #   will be the (float) last factor
    return prime_factors

    
def sudoku_solver(p):
    i = p.find('0')
    if i < 0: yield p
    else:
        for v in set('123456789')-set(p[j] for j in range(81)
            if (i%9==j%9) or (i//9==j//9) or (i//27==j//27 and i%9//3==j%9//3)):
            for s in sudoku_solver(p[:i]+v+p[i+1:]): yield s
             

def main(req: func.HttpRequest) -> func.HttpResponse:

    logging.info('Just imagine! An HTTP trigger ran this Azure Function!')
    n = req.params.get('n')
    s = req.params.get('s')
    if n:
        factor_list = factor_integer(int(n))      # gets a list of factors
        factor_string = ' * '.join([str(f) for f in factor_list])
        reply_string = 'Results: ' + str(n) + ' has ' + str(len(factor_list)) + ' factors, is = ' \
                       + factor_string + ' ... thanks for playing!'
    elif s:
        if len(s) == 81 and s.isnumeric():
            reply_string = ''
            for solution_string in sudoku_solver(s): reply_string += solution_string + '\n'
        else: reply_string = 'could not parse Sudoku puzzle string'
    else: reply_string = "no parameter parsed"

    return func.HttpResponse(reply_string, status_code = 200)
```

* Save this file
* Optional: Read through the code to discern what it does; more on this below
* From the VSCode **`Run`** menu: Start the debugger
    * This will launch the Azure Function locally on your laptop
        * As noted above: Your laptop is running a Server program on behalf of this Azure Function
    * VSCode will stay in Debug *run* mode until you stop it
    * In the course of building the Azure Function (assuming all goes well): VSCode will print a URL in the terminal window
        * For example: **`http://localhost:7071/api/HttpTrigger1`**
            * `localhost` is your computer. `7071` is a **port** or a *dedicated communication channel*. 
        * Copy-paste this URL into your browser address bar
        * This should result (assuming all goes well) in the message `no parameter parsed`

    
The code in the Python file **`__init__.py`** consists of four sections or blocks:
- import libraries
- function **`factor_integer()`**: factor an integer into prime factors
- function **`sudoku_solver`**: solve a Sudoku puzzle
- main: receive a HTTP request and respond to it

    
## 8 Test locally

    
[TOC](#table-of-contents)

    
* run the Azure function with no parameters: Result is `no parameter parsed`
* add the parameter at the end of the URL: `?n=60`
* change this parameter to `?s=027800061040030008910005420500016030000970200070000096700000080006027000030480007`
    
    
When using the parameter key 'n' the Azure Function interprets the request as 'factor this integer value'. 
The key 's' is interpreted as 'solve this Sudoku puzzle'. (A zero is interpreted as a blank square in the
Sudoku puzzle. The solutions reported back have no zeroes.)
    
    


<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/27_1_VSCode_test_Azure_Function_localhost.png" alt="drawing" width="800"/>

<BR>
   
Notice that the Activity Bar context switches from Azure to Debugging. 
    
    
- Reverse engineering: Find the message `no parameter parsed` in the code
    - This is the default when no additional parameters are appended to the Function URL


We have used a browser to interact with a web service.


Notice the **Run / bug** icon in the activity bar displays a blue badge.
This indicates the Azure Function process is running locally.
Stop the Function and this will clear the badge.


## 9 Deploy to Azure


[TOC](#table-of-contents)


To deploy the Azure Function to the cloud we need an Azure Function App. 
We created one of these in the Portal activity above. If we needed to, we
could also create an Azure Function App from VSCode. You can follow this
procedure if you like; or you can skip it and use the existing Azure Function
App (recommended for a first run-through).

    
- In VSCode select the Azure view
- In **`RESOURCES`** expand the Subscription (gold key icon)
- From here expand the **`Function App`** category (lightning bolt icon)
- Right click on **`Function App`** and select **`Create Function App in Azure`**
    - Provide a unique name
    - Choose Python 3.9 kilroy we used 3.8 above
    - Choose West US 2 as the location
        - This may produce a 'No permission message'; if so: Select Existing
    - Select the available Resource Group
    - The creation process takes a minute
    - When you view the output: Notice a URL is assigned to your new Function App
        - This is *not* the same as the URL of your pending Azure Function
    
    
With a Function App place either from the portal build or using the above steps: We can proceed to upload the Azure Function.
    
    
- In VSCode select the Azure view
    
<BR>
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/AzureFunctions_008_UploadFunction.png" alt="drawing" width="100"/>
<BR>
 
- Place your cursor inside the **`WORKSPACE`** panel and select **`Deploy...`** (icon above)
    - Select **`Deploy to Function App`**
    - Select the folder for your Azure Function
    - Select an Azure Function App
        - Either the one you built on the portal or one you built in the preceding steps from VSCode
    - Confirm the Deploy action
    - This also takes a minute to complete
    - Note the publication URL and paste this into a browser address bar
    - Test the Azure Function using the factoring (`?n=2342`) and Sudoku tests as above

    
kilroy above in step 2: the folder needs to be called out in the previous sections so it is obvious

    
The deployment will enable Application Insights by default. This is useful as it allows us to see the logging results
in the console. We can also go to the Azure portal (web browser) to see the Azure Function listed in the default 
Resource Group.


## 10 Programmatic test


[TOC](#table-of-contents)


Next we run the Azure Function from Python. This requires about four lines of Python code. 


    
kilroy which interpreter... do students need to `python -m pip install requests` in some manner?

    

The code below sends an HTTP message to your Azure Function, gets 
a reply, and prints the text of that reply. 
    
    
```
import requests
urlbase='https://rob5-function-app.azurewebsites.net/api/function1_vscode_http_trigger'
full_url = urlbase + '?n=23948'
print(requests.get(full_url).text)
```


    
There are a couple ways to run this code. You can start the Python interpreter
by typing `python` at the command prompt. This gives you the Python prompt `>>> `. 
You can then copy-paste the code one line at a time. 
You can stop Python interpreter by typing `exit()`.

    
As an alternative you can save this code as a file 
with a name like `testFunction.py`; then run the file from the bash command line: 
`python testFunction.py`.


This completes constructing and testing a simple serverless function on Azure. 
The first million-or-so executions of this function incur no cost.


Azure Functions tend to involve connecting 
the serverless function to data resources. While this is 
beyond the scope of this tutorial, a vast array of instructional resources are 
available online. A reasonable project might be to construct a small table
of key-value pairs, place that table into a NoSQL serverless database 
(on Azure this is called **`CosmosDB`**) and use your Azure Function to
retrieve data from that table. See 'stretch problem 2' below for more on this.


## Appendices


[TOC](#table-of-contents)
    

### Logging results in the Azure console

    
[TOC](#table-of-contents)
    
    
- Azure portal Home view: Choose the Function App of interest
    - This gives the Overview view by default: see the emphasis on left menu bar
- Choose Functions from this menu bar to list the function `HttpTrigger1` (or whatever it is named)
- Click on that Trigger; and from the new page, at left, click Monitor
- In the main panel of the portal/console select Logs
    - This brings up a black-background text box
    - Test the Azure Function to see diagnostics printed in this text box
        - Notice that the diagnostics text connects back to the Azure Function code
        - This is a debugging pathway: Your Azure Function can tell you what it thinks is going on.


#### Triggers

A serverless function has a trigger: Something happens to make it run. This might be an alarm clock set 
up as a trigger. It can be a new data file arriving in a storage location, again pre-configured to act as a 
trigger. In this walk-through the trigger is an HTTP request. 


Let's break down the trigger event as two appended strings that are entered into a browser address bar. 
The first string is the URL of the Azure Function. This we are handed in the process of deploying our 
Function. The second string is a list of parameters, in our case just one parameter, that can be parsed
by the Azure Function. Here is the breakdown:

```
URL of the Azure Function is (for example): https://111.22.33.44

Parameter string to pass an integer 'n' with value 105: ?n=105

Two strings appended together, to place in browser address bar: https://111.22.33.44?n=105
```

In practice rather than an ip address like `111.22.33.44` we receive a more human-friendly URL
for our Azure function such as `https://factoring.azurewebsites.net/api/factoring`. 
On the cloud the trigger passes the parameter to the code we have emplaced. For this
code we use Python 3 split across two source code files. 

    
### Stretch Problem 1

    
[TOC](#table-of-contents)

    
Goal: Measure Azure Function time-per-task from VSCode. 


- Create a Client program that calls the Azure Function
- Call the Azure Function multiple times: timing the results
- Investigate: What consumes the execution time: The task or the network traffic?

    
#### Create a Client


```
import requests
urlbase='https://rob5.azurewebsites.net/api/azfn1'
print(requests.get(urlbase + '?n=144').text)
```

This can be executed one at a time using the Python command prompt `>>>` or written
into a Python program file, say named `azfunctionclient.py`. You may use VSCode for this
where it is strongly encouraged that you save the file outside the Azure Function folder. 
The procedure is to create a new file, paste in the above code, and save this file 
*as type **Python*** in a new folder, again outside the folder containing the Azure function. 
The reason for this is to keep your test client (that runs on your local machine) distinct from 
code that goes into your Azure Function.


Run the client program in VSCode using the 
*run* button (green triangle) at the upper right. Verify that the program works properly
by looking at the output in the TERMINAL window. 


#### Step 2

    

    
Modify the program to run 20 Azure Function calls and print the average time required per call.

- Add the line **`import time`** at the top of the file
    - This provides you with a timing library
- Delete the print statement (line 3 of the original program)
- Add code to run the Azure Function 20 times and determine the average time per call
    - The following code blocks can be added in sequence to accomplish this


*Block 1*
```
toc = time.time()
responses = ''
a = 1
b = 21
```

This sets up the parameters to run the Azure Function 20 times and notes the time. 


*Block 2*
```
for i in range(a, b):
    this_response = requests.get(urlbase + '?n=' + str(i)).text
    reduced_response = this_response.replace("playing!", "").replace("for","").replace("thanks","")
    responses += reduced_response.replace("...","") + '\n'    
```

This loop calls the Azure Function 20 times and gets rid of the "... thanks for playing!" message.


*Block 3*

```
tic = time.time()
elapsed_time = tic - toc
print(responses)
print("time per factorization = " + str(elapsed_time / (b-a)))
```

This notes the time again, creates a time difference and prints the average time per Azure Function call.


#### Step 3

    
If you change the range of parameters (1, 21) to much larger numbers, like (1000001, 1000021)
you have presumably made the factoring challenge more time-consuming: The algorithm has more 
work to do. However it is unclear what part of the Azure Function execution takes up how much 
time: Is it the message passing that is time consuming? Or is it the factorization? Or some
combination. 


We can start to get a handle on this by changing the nature of the task to see if this has 
a significant impact on the time elapsed.  


### Stretch Problem 2

    
[TOC](#table-of-contents)

    
Add a binding to an Azure Storage Account and create a very simple access example. For example
you might place a 3-value CSV file in the Storage Account and use a Azure Function parameter `i`
to choose one of those values: 

```
1, banana
2, apple
3, orange
```

Then test with `<baseurl>?i=2` and receive the reply `apple`.

    
kilroy this needs more elaboration
    


### Docker review

    
[TOC](#table-of-contents)

    
While this walk-through is for Azure Functions these remarks are a short review of some key concepts
in containerization. 


- [Windows installation](https://docs.docker.com/docker-for-windows/install/)
- Download the installer, run through the installation, start the Docker app (this takes some time)
- Run through the tutoria ("2 minutes")
    - Notice this tutorial places an active Windows Powershell in the right side of the application panel
    - Running the first two commands `docker run` and `docker cp` in this shell sets in motion:
        - git clone of the github docker-org `getting-started` repo (from `alpine/git:latest`)
        - this is into `~/getting-started`
    - Next is `docker build` from the clone directory: Builds the 101 tutorial. This takes a minute.
    - Next `docker run` runs this newly built docker container, mapping port 80 of the container to port 80 of the OS. 
    - Next `docker tag` and `docker push`; so now this image is registered under my docker user account

    
Let's back up from the "docker image at Docker Hub" part: I use `localhost/tutorial` to see the tutorial web app. 
That is, a running docker container is serving HTML to my browser when I hit that localhost URL. Great; there 
ought to follow some more illumination on the `docker do-something` syntax and the Docker Windows app. 

    
Turning to that app for a moment: The `alpine/git` repo features four action icons but only two are activated: 
Start and Delete. It's status is EXITED(0). The `docker-tutorial` Docker container is RUNNING on port 80 and 
fiveicons are active: Open in browser, CLI, Stop, Restart and Delete. 

    
Clicking on the **CLI** icon gets me a shell window with a `#` prompt. So this is the Part B of the Docker
container: Not only is it "running as a program" but it also "has a shell where I am root". Here is a point of
interest: The process list command `ps -ef` turns up one `master` process, quantity eight `worker process`, 
one `sh` shell and of course `ps -ef` itself. The master and eight workers are all under the `nginx` web server. 
So that is in short the smoking gun of "what this container is doing as an exectuable program" (in addition to
running a shell). 

    
Ok so there is a Docker image out there; and a Docker executable. Is this like a JVM? Going to the executable
from the image is ... well we did a build in the tutorial so I'm voting on the JVM idea. Anyway you get
something (where is it???) and you then run it and there is your textbook quote. 


### Stretch Problem 1 example results


[TOC](#table-of-contents)


<BR>
   
<img src="https://github.com/robfatland/serverless/blob/main/azure/images/31_1_Python_Azure_Function_Client_Timing_Test.png" alt="drawing" width="900"/>


<BR>

